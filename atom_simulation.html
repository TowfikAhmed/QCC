<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0"
		/>
		<title>Atom Simulation</title>
		<style>
			body {
				margin: 0;
				padding: 0;
				background: #000;
				color: #fff;
				font-family: "Arial", sans-serif;
				overflow: hidden;
			}
			#canvas {
				display: block;
				background: radial-gradient(circle at center, #020512, #000000);
			}

			.controls {
				position: absolute;
				top: 20px;
				left: 20px;
				background: rgba(0, 0, 0, 0.8);
				padding: 20px;
				border-radius: 10px;
				backdrop-filter: blur(10px);
				border: 1px solid rgba(255, 255, 255, 0.1);
				z-index: 100;
			}

			.control-group {
				margin-bottom: 15px;
			}

			label {
				display: block;
				margin-bottom: 5px;
				font-size: 14px;
				color: #ccc;
			}

			input[type="range"] {
				width: 220px;
				margin-bottom: 5px;
			}

			button {
				background: linear-gradient(45deg, #40c9ff, #4fd0e4);
				border: none;
				color: white;
				padding: 10px 20px;
				border-radius: 5px;
				cursor: pointer;
				margin-right: 10px;
				margin-bottom: 10px;
				transition: all 0.3s ease;
			}

			button:hover {
				transform: translateY(-2px);
				box-shadow: 0 5px 15px rgba(79, 208, 228, 0.4);
			}

			.value-display {
				color: #4fd0e4;
				font-weight: bold;
			}

			.info-panel {
				position: absolute;
				top: 20px;
				right: 20px;
				background: rgba(0, 0, 0, 0.8);
				padding: 15px;
				border-radius: 10px;
				backdrop-filter: blur(10px);
				border: 1px solid rgba(255, 255, 255, 0.1);
				max-width: 280px;
			}

			.time-display {
				font-size: 18px;
				color: #4fd0e4;
				margin-bottom: 10px;
			}

			.planet-count {
				font-size: 14px;
				color: #ccc;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas"></canvas>
		<div class="controls">
			<h3 style="margin-top: 0; color: #4fd0e4">Atom Controls</h3>

			<div class="control-group">
				<label
					>Electron Speed:
					<span
						class="value-display"
						id="speedValue"
						>1.0</span
					></label
				>
				<input
					type="range"
					id="electronSpeed"
					min="0"
					max="5"
					step="0.1"
					value="1.0"
				/>
			</div>

			<div class="control-group">
				<label
					>Electron Size:
					<span
						class="value-display"
						id="sizeValue"
						>1.2</span
					></label
				>
				<input
					type="range"
					id="electronSize"
					min="0.5"
					max="3"
					step="0.1"
					value="1.2"
				/>
			</div>

			<div class="control-group">
				<label
					>Electron Count:
					<span
						class="value-display"
						id="countValue"
						>10</span
					></label
				>
				<input
					type="range"
					id="electronCount"
					min="1"
					max="30"
					step="1"
					value="10"
				/>
			</div>

			<div class="control-group">
				<label
					>Nucleus Size:
					<span
						class="value-display"
						id="nucleusSizeValue"
						>1.4</span
					></label
				>
				<input
					type="range"
					id="nucleusSize"
					min="0.8"
					max="3"
					step="0.1"
					value="1.4"
				/>
			</div>

			<div class="control-group">
				<label
					>Show Orbitals:
					<span
						class="value-display"
						id="orbitValue"
						>On</span
					></label
				>
				<input
					type="range"
					id="showOrbitals"
					min="0"
					max="1"
					step="1"
					value="1"
				/>
			</div>

			<button onclick="resetSimulation()">Reset</button>
			<button
				onclick="togglePause()"
				id="pauseBtn"
			>
				Pause
			</button>
		</div>

		<div class="info-panel">
			<div
				class="time-display"
				id="timeDisplay"
			>
				Time: 0.0
			</div>
			<div
				class="planet-count"
				id="atomInfoDisplay"
			>
				Electrons: 10 | Protons: 10 | Neutrons: 10 | Shells: 2
			</div>
			<div style="font-size: 12px; color: #888; margin-top: 10px">
				Visualizing a simple Bohr-model atom (labels: e-, p+, n0)
			</div>
		</div>

		<script>
			const canvas = document.getElementById("canvas");
			const ctx = canvas.getContext("2d");

			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;

			let electrons = [];
			let nucleusParticles = [];
			let shells = []; // radii per shell
			let time = 0;
			let isPaused = false;
			let animationId;

			// Controls
			const electronSpeedSlider = document.getElementById("electronSpeed");
			const electronSizeSlider = document.getElementById("electronSize");
			const electronCountSlider = document.getElementById("electronCount");
			const showOrbitalsSlider = document.getElementById("showOrbitals");
			const nucleusSizeSlider = document.getElementById("nucleusSize");

			// Config
			let config = {
				electronSpeed: 1.0,
				electronSize: 1.2,
				electronCount: 10,
				showOrbitals: true,
				nucleusScale: 1.4,
			};

			function drawLabel(
				x,
				y,
				text,
				color = "#fff",
				offsetX = 0,
				offsetY = -12
			) {
				ctx.save();
				ctx.font = "10px Arial";
				ctx.textAlign = "center";
				ctx.textBaseline = "middle";
				ctx.shadowColor = "rgba(0,0,0,0.8)";
				ctx.shadowBlur = 2;
				ctx.fillStyle = color;
				ctx.fillText(text, x + offsetX, y + offsetY);
				ctx.restore();
			}

			class Electron {
				constructor(shellIndex, radius, angle, dir) {
					this.shell = shellIndex; // 1-based
					this.radius = radius;
					this.angle = angle;
					this.dir = dir; // +1 or -1
					this.baseSpeed = 0.02; // radians/frame baseline
					this.color = "#7fe7ff";
					this.x = 0;
					this.y = 0;
				}

				update() {
					const n = this.shell;
					const speed =
						(this.baseSpeed * config.electronSpeed) / Math.pow(n, 1.3);
					this.angle += this.dir * speed;

					const cx = canvas.width / 2;
					const cy = canvas.height / 2;
					this.x = cx + Math.cos(this.angle) * this.radius;
					this.y = cy + Math.sin(this.angle) * this.radius;
				}

				draw() {
					const size = config.electronSize;

					// Glow
					const grad = ctx.createRadialGradient(
						this.x,
						this.y,
						0,
						this.x,
						this.y,
						size * 6
					);
					grad.addColorStop(0, "rgba(127,231,255,0.9)");
					grad.addColorStop(0.5, "rgba(127,231,255,0.3)");
					grad.addColorStop(1, "rgba(127,231,255,0)");
					ctx.fillStyle = grad;
					ctx.beginPath();
					ctx.arc(this.x, this.y, size * 6, 0, Math.PI * 2);
					ctx.fill();

					// Core
					ctx.fillStyle = this.color;
					ctx.beginPath();
					ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
					ctx.fill();

					// Label
					drawLabel(this.x, this.y, "e-", "#bff6ff", 0, -(size + 10));
				}
			}

			class NucleusParticle {
				constructor(type) {
					this.type = type; // 'p' or 'n'
					// Slightly bigger by default
					this.baseRadius = type === "p" ? 7 : 7.5;
					this.color = type === "p" ? "#ff6b6b" : "#f4e8c1";
					this.angle = Math.random() * Math.PI * 2;
					this.rad = Math.random() * 6 + 2; // jitter radius from center
					this.speed = Math.random() * 0.02 + 0.005;
				}
				update() {
					this.angle += this.speed * (Math.random() > 0.5 ? 1 : -1);
				}
				draw(cx, cy) {
					const x = cx + Math.cos(this.angle) * this.rad;
					const y = cy + Math.sin(this.angle) * this.rad;
					const r = this.baseRadius * config.nucleusScale;
					ctx.fillStyle = this.color;
					ctx.beginPath();
					ctx.arc(x, y, r, 0, Math.PI * 2);
					ctx.fill();

					// Label offset slightly outward from center
					const dx = x - cx;
					const dy = y - cy;
					const len = Math.max(1, Math.hypot(dx, dy));
					const ox = (dx / len) * (r + 8);
					const oy = (dy / len) * (r + 8);
					const label = this.type === "p" ? "p+" : "n0";
					const labelColor = this.type === "p" ? "#ffd1d1" : "#fff6d8";
					drawLabel(x + ox, y + oy, label, labelColor, 0, 0);
				}
			}

			function distributeElectrons(count) {
				// Shell capacities per Bohr model (simplified): 2, 8, 18, 32, ...
				const capacities = [2, 8, 18, 32, 50, 72];
				const distribution = [];
				let remaining = count;
				let shellIndex = 0;
				while (remaining > 0 && shellIndex < capacities.length) {
					const take = Math.min(remaining, capacities[shellIndex]);
					distribution.push(take);
					remaining -= take;
					shellIndex++;
				}
				return distribution; // array per shell
			}

			function buildShellRadii(shellCount) {
				const cx = canvas.width / 2;
				const cy = canvas.height / 2;
				const shortest = Math.min(cx, cy);
				const maxRadius = Math.max(120, Math.min(400, shortest - 60));
				const base = 60;
				const step = Math.max(40, (maxRadius - base) / Math.max(1, shellCount));
				const radii = [];
				for (let n = 1; n <= shellCount; n++) {
					radii.push(base + step * (n - 1));
				}
				return radii;
			}

			function createAtom() {
				electrons = [];
				nucleusParticles = [];
				const distribution = distributeElectrons(config.electronCount);
				shells = buildShellRadii(distribution.length);

				// Create electrons per shell
				distribution.forEach((count, idx) => {
					const n = idx + 1;
					const radius = shells[idx];
					const dir = n % 2 === 0 ? -1 : 1; // alternate directions
					for (let i = 0; i < count; i++) {
						const angle =
							(i / Math.max(1, count)) * Math.PI * 2 + Math.random() * 0.2;
						electrons.push(new Electron(n, radius, angle, dir));
					}
				});

				// Simple neutral atom: Z â‰ˆ electronCount, neutrons ~ Z (visual only)
				const Z = Math.max(1, Math.min(30, config.electronCount));
				const N = Z;
				for (let i = 0; i < Z; i++)
					nucleusParticles.push(new NucleusParticle("p"));
				for (let i = 0; i < N; i++)
					nucleusParticles.push(new NucleusParticle("n"));
			}

			function updateControls() {
				document.getElementById("speedValue").textContent =
					electronSpeedSlider.value;
				document.getElementById("sizeValue").textContent =
					electronSizeSlider.value;
				document.getElementById("countValue").textContent =
					electronCountSlider.value;
				document.getElementById("orbitValue").textContent =
					showOrbitalsSlider.value == 1 ? "On" : "Off";
				document.getElementById("nucleusSizeValue").textContent =
					nucleusSizeSlider.value;

				config.electronSpeed = parseFloat(electronSpeedSlider.value);
				config.electronSize = parseFloat(electronSizeSlider.value);
				const newCount = parseInt(electronCountSlider.value, 10);
				const countChanged = newCount !== config.electronCount;
				config.electronCount = newCount;
				config.showOrbitals = showOrbitalsSlider.value == 1;
				config.nucleusScale = parseFloat(nucleusSizeSlider.value);

				if (countChanged) {
					createAtom();
				}
			}

			function drawBackground() {
				// Subtle specks for depth
				ctx.fillStyle = "#fff";
				for (let i = 0; i < 80; i++) {
					const x = (i * 137.035999) % canvas.width;
					const y = (i * 311.728) % canvas.height;
					const alpha = (Math.sin(time * 0.4 + i) * 0.5 + 0.5) * 0.15;
					ctx.globalAlpha = alpha;
					ctx.fillRect(x, y, 1, 1);
				}
				ctx.globalAlpha = 1;
			}

			function drawNucleus() {
				const cx = canvas.width / 2;
				const cy = canvas.height / 2;

				// Glow scaled slightly with nucleus size
				const coreRadius = 24 * Math.max(1, config.nucleusScale * 0.9);
				const grad = ctx.createRadialGradient(
					cx,
					cy,
					0,
					cx,
					cy,
					coreRadius * 3.5
				);
				grad.addColorStop(0, "rgba(255,255,255,0.2)");
				grad.addColorStop(0.2, "rgba(255,224,160,0.1)");
				grad.addColorStop(0.8, "rgba(255,224,160,0.05)");
				grad.addColorStop(1, "rgba(255,224,160,0)");
				ctx.fillStyle = grad;
				ctx.beginPath();
				ctx.arc(cx, cy, coreRadius * 3.5, 0, Math.PI * 2);
				ctx.fill();

				// Core body
				ctx.beginPath();
				ctx.arc(cx, cy, coreRadius, 0, Math.PI * 2);
				ctx.fill();

				// Particles
				nucleusParticles.forEach((p) => {
					p.update();
					p.draw(cx, cy);
				});
			}

			function drawOrbitals() {
				if (!config.showOrbitals) return;
				const cx = canvas.width / 2;
				const cy = canvas.height / 2;
				ctx.strokeStyle = "rgba(255,255,255,0.12)";
				ctx.lineWidth = 1;
				shells.forEach((r) => {
					ctx.beginPath();
					ctx.arc(cx, cy, r, 0, Math.PI * 2);
					ctx.stroke();
				});
			}

			function animate() {
				if (!isPaused && !document.hidden) {
					ctx.clearRect(0, 0, canvas.width, canvas.height);

					drawBackground();
					drawOrbitals();
					drawNucleus();

					electrons.forEach((e) => {
						e.update();
						e.draw();
					});

					time += 0.016;

					// Info
					if (Math.floor(time * 30) % 3 === 0) {
						const Z = Math.max(1, Math.min(30, config.electronCount));
						const N = Z;
						document.getElementById(
							"timeDisplay"
						).textContent = `Time: ${time.toFixed(1)}`;
						document.getElementById(
							"atomInfoDisplay"
						).textContent = `Electrons: ${config.electronCount} | Protons: ${Z} | Neutrons: ${N} | Shells: ${shells.length}`;
					}
				}
				animationId = requestAnimationFrame(animate);
			}

			function resetSimulation() {
				time = 0;
				updateControls();
				createAtom();
			}

			function togglePause() {
				isPaused = !isPaused;
				document.getElementById("pauseBtn").textContent = isPaused
					? "Resume"
					: "Pause";
			}

			// Event listeners
			[
				electronSpeedSlider,
				electronSizeSlider,
				electronCountSlider,
				showOrbitalsSlider,
				nucleusSizeSlider,
			].forEach((slider) => {
				slider.addEventListener("input", updateControls);
			});

			// Handle window resize
			window.addEventListener("resize", () => {
				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight;
				createAtom();
			});

			// Handle page visibility changes
			document.addEventListener("visibilitychange", () => {
				if (document.hidden) {
					isPaused = true;
					document.getElementById("pauseBtn").textContent = "Resume";
				}
			});

			// Cleanup on page unload
			window.addEventListener("beforeunload", () => {
				if (animationId) cancelAnimationFrame(animationId);
				electrons.length = 0;
				nucleusParticles.length = 0;
			});

			// Init
			updateControls();
			createAtom();
			animate();
		</script>
	</body>
</html>
